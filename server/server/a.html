<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>题目</h2>
    
    <p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后 - 力扣（LeetCode）</a></p>
    
    <p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
    
    <p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼
        此之间不能相互攻击。</p>
    
    <p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
    
    <p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
    
    <p><strong>示例 1：</strong></p>
    
    <p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="" /></p>
    
    <p>```
        输入：n = 4
        输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
        解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
    
    <p>```</p>
    
    <p><strong>示例 2：</strong></p>
    
    <p>```
        输入：n = 1
        输出：[["Q"]]</p>
    
    <p>```</p>
    
    <p><strong>提示：</strong></p>
    
    <ul>
        <li><code>1 &lt;= n &lt;= 9</code></li>
    </ul>
    
    <h2>解答</h2>
    
    <p>```c++</p>
    
    <h1>include<iostream>
    </h1>
    
    <h1>include<vector>
    </h1>
    
    <h1>include<string>
    </h1>
    
    <h1>include<algorithm>
    </h1>
    
    <p>using namespace std;</p>
    
    <p>class Solution
        {
        private:
        vector<string> path;
            vector<vector<string>&gt; result;
                public:
                vector<vector<string>&gt; solveNQueens(int n)
                    {
                    //数值&gt;0表示不可放入Queen，数值a大小代表该格可以被a个Queen攻击
                    vector<vector<int>&gt; chessboard(n, vector<int>(n,0));
                            backTrack(0,n,chessboard);
                            return result;
                            }
                            void backTrack(int row, int n, vector<vector<int>&gt;&amp; chessboard)
                                {
                                //递归终止条件
                                //处理完N行返回
                                if(row == n)
                                {
                                result.push<em>back(path);
                                    return;
                                    }
                                    // 从该行遍历
                                    int i = 0;
                                    for(; i &lt; n; i++)
                                    {
                                    // 找到棋盘该行可以放入的位置
                                    if(chessboard[row][i] == 0)
                                    {
                                    path.push</em>back(string(i,'.') + "Q" + string(n-1-i,'.'));
                                // 处理不能放入Q的位置
                                //行
                                for (int boardRow = 0; boardRow &lt; n; boardRow++)
                                {
                                if(boardRow != i)
                                chessboard[row][boardRow]++;
                                }
                                //列
                                for(int boardCol = 0; boardCol &lt; n; boardCol++)
                                {
                                if(boardCol != row)
                                chessboard[boardCol][i]++;
                                }
                                //斜边
                                for(int boardRow = row-min(row,i), boardCol=i-min(row,i); boardRow &lt; n &amp;&amp;
                                boardCol &lt; n; boardRow++,boardCol++)
                                {
                                if(boardRow != row &amp;&amp; boardCol != i)
                                chessboard[boardRow][boardCol]++;
                                }
                                for (int boardRow = row + i - min(i + row, n - 1), boardCol = min(i + row, n - 1); boardRow
                                &lt; n &amp;&amp; boardCol &gt;= 0; boardRow++, boardCol--)
                                {
                                if (boardRow != row &amp;&amp; boardCol != i)
                                chessboard[boardRow][boardCol]++;
                                }</p>
    
    <pre><code>            backTrack(row+1,n,chessboard);
    
                // 撤回不能放入Q的位置
                for (int boardRow = 0; boardRow &lt; n; boardRow++)
                {
                    if (boardRow != i)
                        chessboard[row][boardRow]--;
                }
                // 列
                for (int boardCol = 0; boardCol &lt; n; boardCol++)
                {
                    if (boardCol != row)
                        chessboard[boardCol][i]--;
                }
                // 斜边
                for (int boardRow = row - min(row, i), boardCol = i - min(row, i); boardRow &lt; n &amp;&amp; boardCol &lt; n; boardRow++, boardCol++)
                {
                    if (boardRow != row &amp;&amp; boardCol != i)
                        chessboard[boardRow][boardCol]--;
                }
                for (int boardRow = row + i - min(i + row, n - 1), boardCol = min(i + row, n - 1); boardRow &lt; n &amp;&amp; boardCol &gt;= 0; boardRow++, boardCol--)
                {
                    if (boardRow != row &amp;&amp; boardCol != i)
                        chessboard[boardRow][boardCol]--;
                }
                path.pop_back();
            }
        }
        if(i == n) //剪枝
        {
            return;
        }
    }
    </code></pre>
    
    <p>};
        ```</p>
</body>
</html>